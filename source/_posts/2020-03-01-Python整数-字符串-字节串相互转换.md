---
title: Pythonæ•´æ•°&å­—ç¬¦ä¸²&å­—èŠ‚ä¸²ç›¸äº’è½¬æ¢
tags:
  - è¯­è¨€åŸºç¡€
mathjax: true
comments: false
copyright: false
date: 2020-03-01 12:28:13
categories: åŸºç¡€çŸ¥è¯†
---

> è½¬è½½è‡ª[pythonæ•´æ•°ã€å­—ç¬¦ä¸²ã€å­—èŠ‚ä¸²ç›¸äº’è½¬æ¢-Lixingcongçš„åšå®¢](https://lixingcong.github.io/2016/03/06/convert-data-in-python/#%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2)

**å¯¼èˆª**

| |æ•°å­—|å­—ç¬¦ä¸²|å­—èŠ‚ç |
|-|---|-----|-----|
|åˆ°æ•°å­—|[è¿›åˆ¶è½¬æ¢](#è¿›åˆ¶è½¬æ¢)|[å­—ç¬¦è½¬æ•´æ•°](#å­—ç¬¦toæ•´æ•°)|[å­—èŠ‚ä¸²è½¬æ•´æ•°](#å­—èŠ‚ä¸²toæ•´æ•°)|
|åˆ°å­—ç¬¦ä¸²|str()|[å­—ç¬¦ä¸²ç¼–ç è§£ç ](#å­—èŠ‚ä¸²toå­—ç¬¦ä¸²)|decode('hex')|
|åˆ°å­—èŠ‚ç |[æ•°å­—è½¬å­—ç¬¦ä¸²](#æ•´æ•°toå­—èŠ‚ä¸²)|[å­—ç¬¦ä¸²è½¬å­—èŠ‚ä¸²](#å­—ç¬¦ä¸²toå­—èŠ‚ä¸²)|ğŸˆš|

è¿˜æœ‰å¸¸è§çš„å•ä¸ªå­—ç¬¦è½¬æ¢

|å‡½æ•°|åŠŸèƒ½|è®°å¿†å£è¯€|ä¾‹å­|å¤‡æ³¨|
|--|--|--|--|--|
|chr|æ•°å­—è½¬æˆå¯¹åº”çš„asciiå­—ç¬¦|chré•¿å¾—å¾ˆåƒcharï¼Œå› æ­¤è½¬æˆchar|```chr(65) ==> A```|è¾“å…¥å‚æ•°æœ‰æ•ˆèŒƒå›´ä¸º0~255|
|ord|å•ä¸ªå­—ç¬¦è½¬å¯¹åº”asciiåºå·|dä¸ºdigitæœ€åä¸€ä¸ªå­—æ¯ï¼Œå› æ­¤è½¬æˆæ•°å­—|```ord('A') ==> 65```||

### è¿›åˆ¶è½¬æ¢
10è¿›åˆ¶è½¬16è¿›åˆ¶: 

	hex(16)  ==>  0x10
    
16è¿›åˆ¶è½¬10è¿›åˆ¶: 

int(STRING,BASE)å°†å­—ç¬¦ä¸²STRINGè½¬æˆåè¿›åˆ¶intï¼Œå…¶ä¸­STRINGçš„åŸºæ˜¯baseã€‚è¯¥å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯å­—ç¬¦ä¸²
	
    int('0x10', 16)  ==>  16
    
ç±»ä¼¼çš„è¿˜æœ‰å…«è¿›åˆ¶oct()ï¼Œ äºŒè¿›åˆ¶bin()

16è¿›åˆ¶å­—ç¬¦ä¸²è½¬æˆäºŒè¿›åˆ¶

	hex_str='00fe'
	bin(int('1'+hex_str, 16))[3:]  #å«æœ‰å‰å¯¼0
	# ç»“æœ '0000000011111110'
	bin(int(hex_str, 16))[2:]   #å¿½ç•¥å‰å¯¼0
	# ç»“æœ '11111110'
	
äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æˆ16è¿›åˆ¶å­—ç¬¦ä¸²
	
	bin_str='0b0111000011001100'
	hex(int(bin_str,2))
	# ç»“æœ '0x70cc'


### å­—ç¬¦toæ•´æ•°
10è¿›åˆ¶å­—ç¬¦ä¸²: 

	int('10')  ==>  10

16è¿›åˆ¶å­—ç¬¦ä¸²: 

	int('10', 16)  ==>  16
    # æˆ–è€…
	int('0x10', 16)  ==>  16
	

### å­—èŠ‚ä¸²toæ•´æ•°
ä½¿ç”¨ç½‘ç»œæ•°æ®åŒ…å¸¸ç”¨çš„structï¼Œå…¼å®¹Cè¯­è¨€çš„æ•°æ®ç»“æ„
structä¸­æ”¯æŒçš„æ ¼å¼å¦‚ä¸‹è¡¨

|Format|C-Type|Python-Type|å­—èŠ‚æ•°|å¤‡æ³¨|
|--|--|--|--|--|
|x|pad byte|no value|1| |
|c|char|string of length 1|1| |
|b|signed char|integer|1| |
|B|unsigned char|integer|1| |
|?|_Bool|bool|1| |
|h|short|integer|2| |
|H|unsigned short|integer|2| |
|i|int|integer|4| |
|I|unsigned int|integer or long|4| |
|l|long|integer|4| |
|L|unsigned long|long|4| |
|q|long long|long|8|ä»…æ”¯æŒ64bitæœºå™¨|
|Q|unsigned long long|long|8|ä»…æ”¯æŒ64bitæœºå™¨|
|f|float|float|4| |
|d|double|float|8| |
|s|char[]|string|1| |
|p|char[]|string|1(ä¸æœºå™¨æœ‰å…³)|ä½œä¸ºæŒ‡é’ˆ|
|P|void *|long|4|ä½œä¸ºæŒ‡é’ˆ|

å¯¹é½æ–¹å¼ï¼šæ”¾åœ¨ç¬¬ä¸€ä¸ªfmtä½ç½®

|CHARACTER|BYTE ORDER|SIZE|ALIGNMENT|
|----|----|----|----|
|@|native|native|native|
|=|native|standard|none|
|<|little-endian|standard|none|
|>|big-endian|standard|none|
|!|network (= big-endian)|standard|none|

è½¬ä¹‰ä¸ºshortå‹æ•´æ•°:

	struct.unpack('<hh', bytes(b'\x01\x00\x00\x00'))  ==>  (1, 0)
    
è½¬ä¹‰ä¸ºlongå‹æ•´æ•°: 

	struct.unpack('<L', bytes(b'\x01\x00\x00\x00'))  ==>  (1,)

### æ•´æ•°toå­—èŠ‚ä¸²
è½¬ä¸ºä¸¤ä¸ªå­—èŠ‚: 

	struct.pack('<HH', 1,2)  ==>  b'\x01\x00\x02\x00'

è½¬ä¸ºå››ä¸ªå­—èŠ‚: 

	struct.pack('<LL', 1,2)  ==>  b'\x01\x00\x00\x00\x02\x00\x00\x00'
    
### æ•´æ•°toå­—ç¬¦ä¸²

ç›´æ¥ç”¨å‡½æ•°

	str(100)


### å­—ç¬¦ä¸²toå­—èŠ‚ä¸²
[æˆ‘ç”¨c++å®ç°çš„encode(hex)å’Œdecode(hex)](#CPPå®ç°encode)

**decodeå’ŒencodeåŒºåˆ«**

decodeå‡½æ•°æ˜¯é‡æ–°è§£ç ï¼ŒæŠŠCTå­—ç¬¦ä¸²æ‰€æ˜¾ç¤ºçš„69dda8455c7dd425ã€æ¯éš”ä¸¤ä¸ªå­—ç¬¦ã€‘è§£ç æˆåå…­è¿›åˆ¶å­—ç¬¦\x69\xdd\xa8\x45\x5c\x7d\xd4\x25

    CT='69dda8455c7dd425'
    print "%r"%CT.decode('hex')
    # è¾“å‡ºç»“æœ
    'i\xdd\xa8E\\}\xd4%'

encodeå‡½æ•°æ˜¯é‡æ–°ç¼–ç ï¼ŒæŠŠCTå­—ç¬¦ä¸²æ‰€æ˜¾ç¤ºçš„69dda8455c7dd425ã€æ¯ä¸ªå­—ç¬¦ã€‘ç¼–ç æˆacsiiå€¼ï¼Œasciiå€¼ä¸ºåå…­è¿›åˆ¶æ˜¾ç¤ºï¼Œå ä¸¤ä½ã€‚æ‰§è¡Œä¸‹åˆ—ç»“æœæ˜¾ç¤º36396464613834353563376464343235ç­‰ä»·äºå°†CTç¬¬ä¸€ä¸ªå­—ç¬¦'6'ç¼–ç ä¸º0x36h ç¬¬äºŒä¸ªå­—ç¬¦'9'ç¼–ç ä¸º0x39h

    CT='69dda8455c7dd425'
    print "%r"%CT.encode('hex')
    # è¾“å‡ºç»“æœ
    '36396464613834353563376464343235'
    
> å¯ä»¥ç†è§£ä¸ºï¼šdecodeè§£ç ï¼Œå­—ç¬¦ä¸²å˜çŸ­ä¸€åŠï¼Œencodeç¼–ç ï¼Œå­—ç¬¦ä¸²å˜ä¸ºä¸¤å€é•¿åº¦

decode('ascii')è§£ç ä¸ºå­—ç¬¦ä¸²Unicodeæ ¼å¼ã€‚è¾“å‡ºå¸¦æœ‰'u'
encode('ascii')ï¼Œç¼–ç ä¸ºUnicodeæ ¼å¼ï¼Œå…¶å®pythoné»˜è®¤å¤„ç†å­—ç¬¦ä¸²å­˜å‚¨å°±æ˜¯Unicodeï¼Œè¾“å‡ºç»“æœä¼°è®¡å’ŒåŸæ¥çš„å­—ç¬¦ä¸²ä¸€æ ·ã€‚

å­—ç¬¦ä¸²ç¼–ç ä¸ºå­—èŠ‚ç : 

	'12abc'.encode('ascii')  ==>  b'12abc'

æ•°å­—æˆ–å­—ç¬¦æ•°ç»„: 

	bytes([1,2, ord('1'),ord('2')])  ==>  b'\x01\x0212'

16è¿›åˆ¶å­—ç¬¦ä¸²:

	bytes().fromhex('010210')  ==>  b'\x01\x02\x10'

16è¿›åˆ¶å­—ç¬¦ä¸²: 

	bytes(map(ord, '\x01\x02\x31\x32'))  ==>  b'\x01\x0212'

16è¿›åˆ¶æ•°ç»„: 

	bytes([0x01,0x02,0x31,0x32])  ==>  b'\x01\x0212'


### å­—èŠ‚ä¸²toå­—ç¬¦ä¸²
å­—èŠ‚ç è§£ç ä¸ºå­—ç¬¦ä¸²: 

	bytes(b'\x31\x32\x61\x62').decode('ascii')  ==>  12ab
    
å­—èŠ‚ä¸²è½¬16è¿›åˆ¶è¡¨ç¤º,å¤¹å¸¦ascii: 

	str(bytes(b'\x01\x0212'))[2:-1]  ==>  \x01\x0212

å­—èŠ‚ä¸²è½¬16è¿›åˆ¶è¡¨ç¤º,å›ºå®šä¸¤ä¸ªå­—ç¬¦è¡¨ç¤º: 

	str(binascii.b2a_hex(b'\x01\x0212'))[2:-1]  ==>  01023132

å­—èŠ‚ä¸²è½¬16è¿›åˆ¶æ•°ç»„: 

	[hex(x) for x in bytes(b'\x01\x0212')]  ==>  ['0x1', '0x2', '0x31', '0x32']

é—®é¢˜ï¼šä»€ä¹ˆæ—¶å€™å­—ç¬¦ä¸²å‰é¢åŠ ä¸Š'r'ã€'b'ã€'r'ï¼Œå…¶å®å®˜æ–¹æ–‡æ¡£æœ‰å†™ã€‚æˆ‘è®¤ä¸ºåœ¨Python2ä¸­ï¼Œrå’Œbæ˜¯ç­‰æ•ˆçš„ã€‚

The Python 2.x documentation:

> A prefix of 'b' or 'B' is ignored in Python 2; it indicates that the literal should become a bytes literal in Python 3 (e.g. when code is automatically converted with 2to3). A 'u' or 'b' prefix may be followed by an 'r' prefix.
> 'b'å­—ç¬¦åŠ åœ¨å­—ç¬¦ä¸²å‰é¢ï¼Œå¯¹äºpython2ä¼šè¢«å¿½ç•¥ã€‚åŠ ä¸Š'b'ç›®çš„ä»…ä»…ä¸ºäº†å…¼å®¹python3ï¼Œè®©python3ä»¥bytesæ•°æ®ç±»å‹(0~255)å­˜æ”¾è¿™ä¸ªå­—ç¬¦ã€å­—ç¬¦ä¸²ã€‚
    
The Python 3.3 documentation states:

> Bytes literals are always prefixed with 'b' or 'B'; they produce an instance of the bytes type instead of the str type. They may only contain ASCII characters; bytes with a numeric value of 128 or greater must be expressed with escapes.
> æ•°æ®ç±»å‹byteæ€»æ˜¯ä»¥'b'ä¸ºå‰ç¼€ï¼Œè¯¥æ•°æ®ç±»å‹ä»…ä¸ºasciiã€‚

ä¸‹é¢æ˜¯stackflowä¸Šé¢ä¸€ä¸ªå›ç­”ã€‚æˆ‘è§‰å¾—ä¸é”™ï¼Œæ‹¿å‡ºæ¥è·Ÿå¤§å®¶åˆ†äº«

In Python 2.x
> Pre-3.0 versions of Python lacked this kind of distinction between text and binary data. Instead, there was:

> - unicode = u'...' literals = sequence of Unicode characters = 3.x str
> - str = '...' literals = sequences of confounded bytes/characters
Usually text, encoded in some unspecified encoding.
But also used to represent binary data like struct.pack output.


Python 3.x makes a clear distinction between the types:

> - str = '...' literals = a sequence of Unicode characters (UTF-16 or UTF-32, depending on how Python was compiled)
> - bytes = b'...' literals = a sequence of octets (integers between 0 and 255)

### CPPå®ç°encode
å°±æ˜¯åšä¸ªç¬”è®°ï¼Œæ¯•ç«Ÿåœ¨åšé¢˜Cryptographyæ—¶å€™ç”¨c++å†™å­—ç¬¦ä¸²çš„å¤„ç†å¾ˆè›‹ç–¼ï¼ä¸ºäº†é˜²æ­¢å†æ¬¡é€ è½®å­ï¼Œè®°ä¸‹æ¥ã€‚

	#include <cstring> //ç”¨åˆ°strlenå‡½æ•°
    static unsigned char ByteMap[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8','9', 'a', 'b', 'c', 'd', 'e', 'f' };

    unsigned char hex_2_dec(unsigned char c){
        if(c >= '0' && c <= '9') return c - '0';
        if(c >= 'a' && c <= 'f') return c - 'a' + 10;
    }

    void str_encode(unsigned char *src, unsigned char *dest, int len_of_src) {
        // ä½¿ç”¨æ³¨æ„ï¼šdest_len >= 2*len_src +1ï¼Œæœ€åä¸€ä½æ˜¯å­˜æ”¾'\0'ã€‚
        int t1;
        for (int i = 0; i < len_of_src; ++i) {
            t1 = (int) src[i];
            dest[2 * i] = ByteMap[t1 / 16];
            dest[2 * i + 1] = ByteMap[t1 % 16];
        }
        dest[2 * len_of_src] = 0; //å¿…é¡»å¡«å……æœ€åä¸€ä¸ªä¸º'\0'
    }

    void str_decode(unsigned char *src,unsigned char *dest){
        int len_of_src=strlen((char *)src);
        unsigned char t1;
        for(int i=1;i<=len_of_src;i+=2){
            t1=hex_2_dec(src[i-1]);
            t1= 16*t1 + hex_2_dec(src[i]);
            dest[i/2]=t1;
        }
    }
